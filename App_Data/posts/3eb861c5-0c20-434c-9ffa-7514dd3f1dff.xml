<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<post>
  <author>mwrock</author>
  <title>Is changing an API or design solely for testability a good practice?</title>
  <description />
  <content>&lt;p&gt;&lt;a href="http://www.mattwrock.com/image.axd?picture=image_20.png"&gt;&lt;img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px 10px 0px 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="http://www.mattwrock.com/image.axd?picture=image_thumb_20.png" width="495" height="284" /&gt;&lt;/a&gt;There is a personal story behind this topic that I want to share. About five years ago I heard about this thing called &lt;a href="http://en.wikipedia.org/wiki/Test-driven_development"&gt;Test Driven Development (TDD)&lt;/a&gt;. For anyone unaware of this, it is where you write failing tests first and then write “the code” later to make them pass. It immediately struck me as interesting and the more I learned about it the more I liked it. It seemed like much more than a means of testing code but a design style that could transform the way we write software.&lt;/p&gt;  &lt;p&gt;As I actually began to practice this discipline, it did completely change the way I write code and approach design. It has been very challenging and rewarding. I don’t at all consider myself polished or advanced but I have drunk the &lt;a href="http://www.kraftbrands.com/koolaid/"&gt;Kool-Aid&lt;/a&gt; and hey, who doesn’t like Kool-Aid!? I cover more specifics later but please, let me reminisce.&lt;/p&gt;  &lt;p&gt;At the time when I was discovering this technique, I purposely sought out a team of developers who were TDD practitioners. As someone who is self taught and prefers to learn on my own, this was an area I knew I needed to learn from others to better get my head around the patterns. So for almost three years I was immersed with my new team. We often discussed the virtues of strong unit test coverage and TDD. When you roll with a group that all share a common set of values, it is easy to feel “right” and take some nuances for granted. Even if they are right.&lt;/p&gt;  &lt;h2&gt;Maybe the world IS flat&lt;/h2&gt;  &lt;p&gt;Six months ago I changed teams. The new team was different from my former team. One difference was a lack of unit testing. There were lots of tests but they were essentially integration tests and took a long time to run. So long that they could not be run as part of the build. Tests were always written after coding and one reason why was that the code itself was nearly impossible to test using typical Unit Testing techniques.&lt;/p&gt;  &lt;p&gt;One of my initial thoughts going in was that this would be an excellent opportunity to make a difference for the better. I still believe this but I was very surprised at how some of my techniques and the patterns that I had come to embrace were questioned and given some rather skeptical critiques. Suddenly it felt that the things I had come to value in standards of design and build methodologies was a currency not honored in this foreign land.&lt;/p&gt;  &lt;p&gt;Now it would have been one thing if I was working for some mediocre outfit of 9 to 5er developers. However many of these were people I consider to be very smart and passionate about writing good software. It was like having a bunch of Harvard grads insisting the earth is flat and watching yourself begin to question if the world really is round. Sure does look flat when you really look at it.&lt;/p&gt;  &lt;blockquote&gt;   &lt;h2&gt;Not everyone likes chocolate and some who don’t are smart&lt;/h2&gt;    &lt;p&gt;&lt;strong&gt;Sidebar&lt;/strong&gt;: I just learned today that &lt;a href="http://www.radiotfs.com/Show/31/TFSatCodePlex"&gt;Jonathan Wanagel&lt;/a&gt;, who runs &lt;a href="http://www.codeplex.com/"&gt;Codeplex&lt;/a&gt; and is one of the smartest people I know in the whole wide world does not care much for chocolate. Interesting…&lt;/p&gt; &lt;/blockquote&gt;  &lt;h2&gt;What is this Hippie code?&lt;/h2&gt;  &lt;p&gt;Here is a list of many of the things that turned some people off:&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;Interfaces – adding too many types to the API, kills &lt;a href="http://weblogs.asp.net/scottgu/archive/2010/08/24/search-and-navigation-tips-tricks-with-visual-studio.aspx"&gt;Visual Studio’s F12&lt;/a&gt; and overkill when there is only a single production implementation. &lt;/li&gt;    &lt;li&gt;Unsealing classes, adding virtual methods or making some private/internal types public – Now we have to support a larger surface area and make sure customers do not get confused or shoot themselves in the foot. &lt;/li&gt;    &lt;li&gt;Eliminating static classes – now I need to instantiate a class to access a simple utility or helper method. &lt;/li&gt;    &lt;li&gt;Test methods with long method names resembling a sentence describing what is being tested –that’s just weird. &lt;/li&gt;    &lt;li&gt;A general concern expressed by many - We should not have to change code and especially an API just to add testability. &lt;/li&gt; &lt;/ul&gt;  &lt;p&gt;Some of these concerns are very valid. Honestly they are all valid. Even though I completely disagree with some of the opinions I have encountered, it must be remembered that introducing new ideas will be naturally distasteful to some if they do not understand the intent and it is therefore incumbent upon the bringer of the new ideas to clarify and articulate why such ideas might have value. I’m not claiming “mission accomplished” but this forced me to do a lot of “back to basics” research to understand how to communicate the value. While I feel the value deep in my bones, it has been very challenging to learn how to express the value to others.&lt;/p&gt;  &lt;h2&gt;Lets play Devil’s Advocate&lt;/h2&gt;  &lt;p&gt;Before I dive into the responses I have developed and am still developing for the above reactions to a different style of design I would like to spend some time defending the critics and skeptics. I work with very intelligent people and I respect the fact that they demand to understand why someone suggests a change in style and a radical change in some respects.&lt;/p&gt;  &lt;p&gt;Personally I spent more than half my career not practicing TDD or writing proper unit tests. I too was very conservative about what my API exposed. I liked to write APIs with few classes. I liked “noun” style classes (employee, order, etc) with their own persistence logic and static Create methods. I thought this was elegant and a lot of others think so too. And honestly, I wrote some code that made some people a lot of money during this time.&lt;/p&gt;  &lt;h2&gt;Sealed classes, internal methods, oh boy!&lt;/h2&gt;  &lt;p&gt;Among the crowd I run with on the twitters, there is a lot of nay saying around sealed classes and internal methods. Don’t expect me to be changing my Add New Class template to create them sealed by default but I do think this deserves some thought. My background is largely in web technologies. This often means that my server code will never be exposed to anyone outside of my team. It is easy to adopt much looser rules around api exposure when you are the only consumer.&lt;/p&gt;  &lt;p&gt;I am also involved in open source software. We are a small cadre of developers and we are not representative of the average developer. I know. That sounds elitist but it is true. I’m used to reading source code in lieu of documentation (not necessarily a good thing). I’m perfectly comfortable pulling down someone else’s code using any of a half dozen source control providers. And like many of my OSS peeps, I get extremely annoyed when I am trying to work with an API, find some code that looks to be just what I need and then see it is not accessible. I’d rather have a larger api that provides me heightened flexibility and extensibility over a smaller and easier to understand API – within reason of course.&lt;/p&gt;  &lt;p&gt;However, when you work on software that physically ships to enterprise customers, you really do need to broaden your view. I might work for Microsoft, but if you call me an enterprise customer, I’ll cry. The fact is, it is important to understand your audience. Most developers don’t want to concern themselves with the innards of your code. That’s why they buy it. It should do everything they need it to do and be easy to figure out and difficult to misuse. No matter who your audience is, the public API is one of the most important things to get right. It should read like documentation and be self explanatory. Sometimes this means putting a curtain over large parts of your codebase. I’m still coming to terms with this, but I do believe it is a reality that deserves attention.&lt;/p&gt;  &lt;h2&gt;Testability for its own sake – That’s just fine&lt;/h2&gt;  &lt;p&gt;I used to feel an uneasiness when discussions would take this turn into warnings about the dangers of making code testable simply for its own sake. I would feel a sense of guilt about asking others to work harder just to make things easier to test. I’m over that. This is like arguing against quality for its own sake or simplicity just to be simple. If I have to tweak an API to make it testable, we have to remember that we are not only doing ourselves a favor but everyone who will be using our software can now test around it as well. &lt;/p&gt;  &lt;p&gt;While TDD and similar practices have been fairly mainstream in other communities for a while, it is becoming more so in the Microsoft dominated technologies (where I work) and much more so than it was just a few years ago. We need to understand that testability ships as a feature to our customers. Software that is difficult to test is not just perceived as a nuisance but its overall quality can be called into question by virtue of a lack of testability.&lt;/p&gt;  &lt;h2&gt;So what is so great about testability? &lt;/h2&gt;  &lt;p&gt;Perhaps I’ve gone far too long in this post before championing the virtues of testability not to mention some clear examples of what it is. I can hear others questioning: what are you talking about? We have QA staff and huge suites of test automation. Testability? Lets not get carried away.&lt;/p&gt;  &lt;p&gt;Yes. Testability is very much about testing the code that you have written. Specifically, I am referring to the ability to test small single units of code (an IF block for example) without the side effects of surrounding code. I might have a method that queries a database for a value, sets the state of the application depending on the value queried and logs the result. I want to be able to write tests that can check that I set the application state appropriately but not that I got the right data from the database or that I successfully logged the activity. I’ll write other tests for that.&lt;/p&gt;  &lt;p&gt;Having a code base well covered with these kinds of tests can create (but does not guarantee) a very high quality bar and allow developers to spend more time writing features and less time finding and fixing bugs. The more logical paths your code can take, the more important this is. It is easy to innocently introduce a small change and inadvertently break several logic paths. This level of code coverage is your safety net from bug whack-a-mole. Each release without this coverage brings increased surface area for bug creation until the &lt;a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"&gt;cyclomatic complexity&lt;/a&gt; drives you to a saturation point and now you spend most of your time addressing bugs.&lt;/p&gt;  &lt;p&gt;Good test coverage and code that is easy to test invites exploration and experimentation. It is the fence that keeps us from touching the third rail. Low coverage incites fear into the hearts and minds of good developers. “Hmm. That sounds like a really interesting approach but we don’t dare touch that code because it is core to our business and we cant afford for it to break.“&lt;/p&gt;  &lt;h2&gt;Testable code is more about good design than a test automation arsenal&lt;/h2&gt;  &lt;p&gt;This is something that can sound odd to the unindoctrinated. At least it was not what originally attracted me to TDD but it IS what has kept me here.&lt;/p&gt;  &lt;p&gt;In order to write code that is easy, let alone possible, to test with this kind of granularity, one must enforce a strict separation of concerns because you want to test no more than a single concern at a&amp;#160; time. This may produce code that looks different to many teams and might look awkward at first glance. The code is more likely to have these traits:&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;More types. More classes, more methods and more interfaces. As one ensures that each type contains a highly focused and intent driven purpose. Rather than having a person class that not only represents the person but also does a bunch of stuff to and with a person, one may now have several classes that look more like verbs than nouns to represent different interactions with a person. &lt;/li&gt;    &lt;li&gt;Smaller types and smaller methods. This goes hand in hand with the above. It does not take a genius (that’s why I figured it out) to discover that it is tough to test a method that does 20 things. And guess what? It is easier to read and understand too. &lt;/li&gt;    &lt;li&gt;More layers of abstraction and points of extensibility. This may coincide with the mention of more interfaces. As you tease out corners of code to test, you need to be able to apply protective tape over surrounding machinery that should remain untouched by the test. This may be because these surrounding areas talk to out of process systems that would bog down the performance of a test or engage in complex logic that manipulates values that must interact with the code under test. It is easier to “plug in” lighter weight machinery that acts on data very predictably, repeatably and quickly. The use of interfaces, dependency injection and mocks/stubs/fakes/etc come into play here and may make one not used to them feel out of water or like they are over engineering. One may react that this abstraction seems silly. Why create an INamingService when we only have one naming service. First, that is a fair point and should not be ignored. It is possible to over engineer and you need to decide what level of abstraction your scenario calls for. That said, once you gain competence coding in this manner, you often find ways to exploit these abstractions into rich composition models that would not have been possible given a more monolithic class structure. &lt;/li&gt;    &lt;li&gt;A larger surface area to the API. This is what many find the hardest to come to terms with and they should. There is A LOT to be said for a simple API and testability does not necessarily make this fate an inevitability. However it does make it more likely. With an application having more “building blocks” there may be a greater number of these blocks to interact with one another and exposing those interactions to the consumer may very well be a good thing. Also, just like you, your consumers writing code around your API may demand testability and the ability to abstract away all exposed blocks. &lt;/li&gt; &lt;/ul&gt;  &lt;h2&gt;This design style facilitates change, improvement and happy developers&lt;/h2&gt;  &lt;p&gt;Code that is easy to compose in different ways is easier to change. This kind of a model allows you to touch smaller and more isolated pieces of your infrastructure, making change a less risky and dreaded endeavor. A team that is empowered to change and improve their code more rapidly makes for a happier team, happier business stake holders and happier customers.&lt;/p&gt;  &lt;h2&gt;Use modern tools for modern programming techniques&lt;/h2&gt;  &lt;p&gt;Ok. I’m gonna call TDD (because that’s usually what this methodology becomes more or less) a “modern programming technique.” There are tools out there that are designed to make these practices easier to implement. As a primarily C# developer, these tools include &lt;a href="http://www.jetbrains.com/resharper/"&gt;Resharper&lt;/a&gt;, an &lt;a href="http://martinfowler.com/articles/injection.html"&gt;IOC for dependency injection&lt;/a&gt;, a good mocking framework and a modern test runner like &lt;a href="http://xunit.codeplex.com/"&gt;XUnit&lt;/a&gt;.&lt;/p&gt;  &lt;p&gt;Resharper makes a lot of the refactorings like extracting interfaces and finding interface implementations and their usages easier to discover. It provides navigational aides making work in a code base with more types much easier.&lt;/p&gt;  &lt;p&gt;An IOC facilitates the creation of these types and makes it easier to manage either swapping out one type for another or discovering all implementations of a given type. One may find constructors with several types being injected which would be extremely awkward to “new up.” With a properly wired IOC, it handles the newing for you. Almost all IOCs (don’t create your own) provide solid lifetime management as well which provide the utility of singleton classes but without their untestability.&lt;/p&gt;  &lt;h2&gt;The wrong question&lt;/h2&gt;  &lt;p&gt;So lets return to the core question of this post. Is changing an API or design solely for testability a good practice? I would argue that we have not properly phrased the question. Begin by exploring your definition of “testability” and you may well discover that the “sake of testability” is not nearly all that you are after.&lt;/p&gt;</content>
  <ispublished>True</ispublished>
  <isdeleted>False</isdeleted>
  <iscommentsenabled>True</iscommentsenabled>
  <pubDate>2013-01-29 02:30:44</pubDate>
  <lastModified>2013-06-02 05:47:14</lastModified>
  <raters>0</raters>
  <rating>0</rating>
  <slug>Is-changing-an-API-or-design-solely-for-testability-a-good-practice</slug>
  <tags />
  <comments>
    <comment id="735f8515-01c0-489f-97d4-25d77c1c7ff4" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-29 05:47:32</date>
      <author>Harry McIntyre</author>
      <email>mcintyre321@gmail.com</email>
      <country />
      <ip>212.124.236.1</ip>
      <moderatedby>mwrock</moderatedby>
      <avatar />
      <content>

IMO it&amp;#39;s very important to make sure you are doing TDD and not test-first/unit testing (as defined at http://sermoa.wordpress.com/2011/05/11/how-bdd-focusses-on-the-why/) to avoid the tests becoming a highly coupled burden, preventing easy refactoring.

These days I prefer BDD tests, and end-to-end stubbing, so tests run quickly, but don&amp;#39;t affect the architecture (e.g. using a custom Fiddler.Core http-proxy level, in-memory database etc.), and the test suite reflects the customers requirements only. This way I can write horrible code, with statics classes that are too big, and pass the  and I can change them, without having to rewrite 40 tests each time I want to change a method to a Strategy.

</content>
    </comment>
    <comment id="2203e395-7995-4d29-ad4a-22373d5a81da" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-29 07:30:40</date>
      <author>Robert Schroeder</author>
      <email>rmschroeder@hotmail.com</email>
      <country />
      <ip>75.150.98.197</ip>
      <avatar />
      <content>RE: Eliminating static classes – now I need to instantiate a class to access a simple utility or helper method.

I have found a lot of luck with static methods on static classes and passing around Func&amp;lt;T,U&amp;gt; in a functional style -- this is very different than static classes that are called directly. The former is very testable (in fact pushing out state makes them much easier to test and think about).

I find that people confuse these things a bit -- the goal is a single, easily replaceable unit of code, and Func&amp;lt;&amp;gt;&amp;#39;s work great there, but static classes with static references do not.</content>
    </comment>
    <comment id="8736e60e-809c-4e2e-95a0-a4c05de50e48" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-29 08:13:59</date>
      <author>Jeff Putz</author>
      <email>jeff@popw.com</email>
      <country />
      <ip>24.142.139.194</ip>
      <avatar />
      <content>Jonathan doesn&amp;#39;t like chocolate? WTF is wrong with him?</content>
    </comment>
    <comment id="dfd52b20-ca7e-4e24-b65b-5cc01b97a258" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-29 09:36:40</date>
      <author>Steven Wilssens</author>
      <email>steven.wilssens@microsoft.com</email>
      <country />
      <ip>131.107.147.166</ip>
      <avatar />
      <content>Jeff is correct. No chocolate for Jonathan? That&amp;#39;s just wrong...</content>
    </comment>
    <comment id="a567fb4f-f34c-4d13-88ab-48eceae2cb39" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-29 23:05:16</date>
      <author>Pop Catalin</author>
      <email>pop.catalin@gmail.com</email>
      <country />
      <ip>91.208.120.254</ip>
      <moderatedby>mwrock</moderatedby>
      <avatar />
      <content>&amp;quot;Is changing an API or design solely for testability a good practice?&amp;quot;

Generally yes, but I would never recommend this practice to anyone without clearly explaining what the exceptions might be.

If the change is not impacting API surface, then you are probably making a good change.Note: Adding interfaces or abstract base classes does not necessarily change the surface of the API, because it does not expose more implementation details than necessary. 

If however, this change surfaces allot more of implementations details than necessary, then you might have done something horrible in the name of a good practice, by making the API more difficult to use, test, support, version, evolve or upgrade.

Sometimes there are other concerns that might conflict with testability, like security, backward compatibility, strong enforcement of some contacts. Then changing the API &amp;quot;solely for testability&amp;quot; might become a hard decision that must be really thought through to see what the impact would be.

If the answer to the question &amp;quot;Can you make this API testable, without exposing private details or affecting security or versioning or break other concerns?&amp;quot; is yes, then you should make you API testable right away. Otherwise sit down and think of a solution or a compromise or of a replacement strategy or of something else.

I&amp;#39;m a big fan of unit testing, TDD, etc, and it is a really good hammer that I prefer against other tools, but not everything is a nail.



</content>
    </comment>
    <comment id="853d4cda-e60c-46ac-b77b-492791b1481f" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2013-01-30 03:00:28</date>
      <author>James Dixon</author>
      <email>jamie@tenfingersfree.com</email>
      <country />
      <ip>98.101.149.96</ip>
      <avatar />
      <content>Great post.  Thanks</content>
    </comment>
  </comments>
  <categories />
  <notifications>
    <email>mcintyre321@gmail.com</email>
    <email>rmschroeder@hotmail.com</email>
    <email>jeff@popw.com</email>
    <email>steven.wilssens@microsoft.com</email>
    <email>pop.catalin@gmail.com</email>
  </notifications>
</post>