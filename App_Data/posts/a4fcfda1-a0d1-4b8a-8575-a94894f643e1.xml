<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<post>
  <author>mwrock</author>
  <title>Resolving InvalidCastException when two different versions of Structuremap are loaded in the same appdomain</title>
  <description />
  <content>&lt;p&gt;Last week I was integrating my automatic css merge, minify and sprite utility, &lt;a href="http://RequestReduce.com"&gt;RequestReduce&lt;/a&gt;, into the MSDN Forums and search applications. Any time you have the opportunity to integrate a component into a new app, there are often new edge cases to explore and therefore new bugs to surface since no app is exactly the same. Especially if the application has any level of complexity.&lt;/p&gt;  &lt;p&gt;The integration went pretty smotthly until I started getting odd Structuremap exceptions in the search application. I had never encountered these before. I had a type that was using the HybridHttpOrThreadLocalScoped Lifecycle and when structuremap attempted to create this type I received the following error:&lt;/p&gt;  &lt;p&gt;System.InvalidCastException: Unable to cast object of type 'StructureMap.Pipeline.MainObjectCache' to type 'StructureMap.Pipeline.IObjectCache'&lt;/p&gt;  &lt;p&gt;Well that’s odd since MainObjectCache derives from IObjectCache. This smelled to me like some sort of a version conflict. The hosing application also uses Structuremap and uses version 2.6.1 while my component RequestReduce uses 2.6.3. I use &lt;a href="http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx"&gt;IlMerge&lt;/a&gt; to merge RequestReduce and its dependencies into a single dll - RequestReduce.dll. While Nuget does make deployment much more simple, I still like having just a single dll for consumers to drop into their bin.&lt;/p&gt;  &lt;p&gt;Unfortunately, searching online for this exception turned up absolutely nothing; so I turned to &lt;a href="http://www.reflector.net/"&gt;Reflector&lt;/a&gt;. The exception was coming from the HttpContextLifecycle class and it did not take long to track down what was happening. HttpContextLifecycle includes the following code:&lt;/p&gt;  &lt;div id="codeSnippetWrapper"&gt;   &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;readonly&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; ITEM_NAME = &lt;span style="color: #006080"&gt;&amp;quot;STRUCTUREMAP-INSTANCES&amp;quot;&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; EjectAll()&lt;br /&gt;{&lt;br /&gt;    FindCache().DisposeAndClear();&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; IObjectCache FindCache()&lt;br /&gt;{&lt;br /&gt;    IDictionary items = findHttpDictionary();&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!items.Contains(ITEM_NAME))&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;lock&lt;/span&gt; (items.SyncRoot)&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!items.Contains(ITEM_NAME))&lt;br /&gt;            {&lt;br /&gt;                var cache = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MainObjectCache();&lt;br /&gt;                items.Add(ITEM_NAME, cache);&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cache;&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (IObjectCache) items[ITEM_NAME];&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; Scope { get { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; InstanceScope.HttpContext.ToString(); } }&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; HasContext()&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; HttpContext.Current != &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; DisposeAndClearAll()&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; HttpContextLifecycle().FindCache().DisposeAndClear();&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;virtual&lt;/span&gt; IDictionary findHttpDictionary()&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!HasContext())&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; StructureMapException(309);&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; HttpContext.Current.Items;&lt;br /&gt;}&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;Its ITEM_NAME which is the culprit here. This is a static readonly field that is the key to the object cache stored in the HttpContext. There is no means to change or override this so whichever version of Structuremap is the first to create the cache, the other version will always throw an error when retrieving the cache because while both with store an IObjectCache, they will be different versions of IObjectCache and therefore different classes altogether which will lead to an InvalidCastException when one tries to cast to the other.&lt;/p&gt;

&lt;p&gt;The work around I came up with was to create a new class that has the same behavior as HttpContextLifecycle but uses a different key:&lt;/p&gt;

&lt;div&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; RRHttpContextLifecycle : ILifecycle&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;readonly&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; RRITEM_NAME = &lt;span style="color: #006080"&gt;&amp;quot;RR-STRUCTUREMAP-INSTANCES&amp;quot;&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; EjectAll()&lt;br /&gt;    {&lt;br /&gt;        FindCache().DisposeAndClear();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;protected&lt;/span&gt; &lt;span style="color: #0000ff"&gt;virtual&lt;/span&gt; IDictionary findHttpDictionary()&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!HttpContextLifecycle.HasContext())&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; StructureMapException(309);&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; HttpContext.Current.Items;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; IObjectCache FindCache()&lt;br /&gt;    {&lt;br /&gt;        var dictionary = findHttpDictionary();&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!dictionary.Contains(RRITEM_NAME))&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;lock&lt;/span&gt; (dictionary.SyncRoot)&lt;br /&gt;            {&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (!dictionary.Contains(RRITEM_NAME))&lt;br /&gt;                {&lt;br /&gt;                    var cache = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MainObjectCache();&lt;br /&gt;                    dictionary.Add(RRITEM_NAME, cache);&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cache;&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (IObjectCache)dictionary[RRITEM_NAME];&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; Scope&lt;br /&gt;    {&lt;br /&gt;        get { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;RRHttpContextLifecycle&amp;quot;&lt;/span&gt;; }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;As you can see, I copy most of the code from HttpContextLifecycle but use a different key for the string and scope. To get this all wired up correctly with HybridHttpOrThreadLocalScoped, I also need to subclass HttpLifecycleBase. Here is the code from HttpLifecycleBase:&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;abstract&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; HttpLifecycleBase&amp;lt;HTTP, NONHTTP&amp;gt; : ILifecycle&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;where&lt;/span&gt; HTTP : ILifecycle, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt;()&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;where&lt;/span&gt; NONHTTP : ILifecycle, &lt;span style="color: #0000ff"&gt;new&lt;/span&gt;()&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;readonly&lt;/span&gt; ILifecycle _http;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;readonly&lt;/span&gt; ILifecycle _nonHttp;&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; HttpLifecycleBase()&lt;br /&gt;    {&lt;br /&gt;        _http = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; HTTP();&lt;br /&gt;        _nonHttp = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; NONHTTP();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; EjectAll()&lt;br /&gt;    {&lt;br /&gt;        _http.EjectAll();&lt;br /&gt;        _nonHttp.EjectAll();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; IObjectCache FindCache()&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; HttpContextLifecycle.HasContext()&lt;br /&gt;                   ? _http.FindCache()&lt;br /&gt;                   : _nonHttp.FindCache();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;abstract&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; Scope { get; }&lt;br /&gt;}&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;div&gt;All HybridHttpOrThreadLocalScoped does is derrive from HttpLifecycleBase and use HttpContextLifecycle as the HTTP cache; so I need to do the same using RRHttpContextLifecycle instead:&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; RRHybridLifecycle : HttpLifecycleBase&amp;lt;RRHttpContextLifecycle, ThreadLocalStorageLifecycle&amp;gt;&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;override&lt;/span&gt; &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; Scope&lt;br /&gt;    {&lt;br /&gt;        get&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;RRHybridLifecycle&amp;quot;&lt;/span&gt;;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;Then I change my container configuration code from:&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;x.For&amp;lt;SqlServerStore&amp;gt;().HybridHttpOrThreadLocalScoped().Use&amp;lt;SqlServerStore&amp;gt;().&lt;br /&gt;    Ctor&amp;lt;IStore&amp;gt;().Is(y =&amp;gt; y.GetInstance&amp;lt;DbDiskCache&amp;gt;());&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;div&gt;to&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;
  &lt;div id="codeSnippetWrapper"&gt;
    &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;x.For&amp;lt;SqlServerStore&amp;gt;().LifecycleIs(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; RRHybridLifecycle()).Use&amp;lt;SqlServerStore&amp;gt;().&lt;br /&gt;    Ctor&amp;lt;IStore&amp;gt;().Is(y =&amp;gt; y.GetInstance&amp;lt;DbDiskCache&amp;gt;());&lt;br /&gt;&lt;/pre&gt;

    &lt;br /&gt;&lt;/div&gt;
This does feel particularly dirty. Copying and pasting code always feels wrong. What happens if Structuremap makes changes to the implementation of HttpContextLifecycle and I do not update my code to sync with those changes. You can see how this could become fragile. It would be nice if ITEM_NAME were not static and there was a way for derived types to override it. Or if the key name at least was appended by the version name of the Structuremap assembly.&lt;/div&gt;

&lt;div&gt;Well until such changes are made in Structuremap, I see no better alternative to my work around.&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;I hope this is helpful to any others who have experienced this scenario. I am also very open to suggestions for a better workaround. In the meantime, I have submitted a pull request to the Structuremap repository that appends the assembly version to the the HttpContext.Items key name.&lt;/div&gt;</content>
  <ispublished>True</ispublished>
  <isdeleted>False</isdeleted>
  <iscommentsenabled>True</iscommentsenabled>
  <pubDate>2011-09-19 00:11:07</pubDate>
  <lastModified>2011-09-19 00:54:35</lastModified>
  <raters>0</raters>
  <rating>0</rating>
  <slug>Resolving-InvalidCastException-when-two-different-versions-of-Structuremap-are-loaded-in-the-same-appdomain</slug>
  <tags />
  <comments />
  <categories />
  <notifications />
</post>