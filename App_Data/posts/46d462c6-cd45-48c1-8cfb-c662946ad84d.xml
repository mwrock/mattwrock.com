<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<post>
  <author>mwrock</author>
  <title>Convert 32 bit PNGs to high quality 8 bit PNGs with C#</title>
  <description />
  <content>&lt;p&gt;I’ve been working on a C# HTTPModule called &lt;a href="http://www.requestreduce.com"&gt;RequestReduce&lt;/a&gt; that sprites CSS background images on the fly as well as merges and Minifes all CSS resources in the document head. For those who may not know, image spriting is a technique that takes individual images in separate image files and merges them into a single file. By tracking the offsets of where each image begins, you can use CSS syntax to limit a css background image to just one of the images in the file like so:&lt;/p&gt;  &lt;div id="codeSnippetWrapper"&gt;   &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;background: url(/RequestReduceContent/94b703a23cf3a2644577ab68fa465844-e2d1ced7efd8cd883516e2da4e51a9d5.png) -241 0 no-repeat&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;By using this technique effectively, page load times will be faster since there will be fewer HTTP connections opened.&lt;/p&gt;

&lt;p&gt;One of the items on my backlog has been image optimization. I had envisioned a feature that would either shell out to one of the popular PNG compressors or allow users a means of plugging in a compressor of their choice. About a week or two before releasing this project at work where I work on the Microsoft EPX Galleries team where we produce among many other galleries, the Visual Studio Gallery and the MSDN Code Samples Gallery, I was in a meeting discussing image optimization and someone was demonstrating the benefits of optimizing some of the images that get published in the MSDN dev centers. The impact on size was enormous and on the level of producing images several times smaller than their unoptimized originals.&lt;/p&gt;

&lt;p&gt;So I figured how difficult could it be to add this feature to RequestReduce? My plan was to shell out to optipng.exe - a very popular and effective C Library that losslessly compresses PNG images. The answer was not difficult at all and the code looked something like this:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; InvokeExecutable(&lt;span style="color: #0000ff"&gt;string&lt;/span&gt; arguments, &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; executable)&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;using&lt;/span&gt;(var process = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Process())&lt;br /&gt;    {&lt;br /&gt;        process.StartInfo = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ProcessStartInfo()&lt;br /&gt;        {&lt;br /&gt;            UseShellExecute = &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;,&lt;br /&gt;            RedirectStandardOutput = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;,&lt;br /&gt;            CreateNoWindow = &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;,&lt;br /&gt;            FileName = executable,&lt;br /&gt;            Arguments = arguments&lt;br /&gt;        };&lt;br /&gt;        process.Start();&lt;br /&gt;        process.StandardOutput.ReadToEnd();&lt;br /&gt;        process.WaitForExit(10000);&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(!process.HasExited)&lt;br /&gt;        {&lt;br /&gt;            process.Kill();&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; OptimizationException&lt;br /&gt;                (&lt;span style="color: #0000ff"&gt;string&lt;/span&gt;.Format(&lt;span style="color: #006080"&gt;&amp;quot;Unable to optimize image using executable {0} with arguments {1}&amp;quot;&lt;/span&gt;, &lt;br /&gt;                executable, arguments));&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;However, I was seeing image size reductions that were much less dramatic than the ones demoed in the meeting I attended. The reason was that I work with Web Devs who are typically good about optimizing images and the presenter in the meeting was referring to “site managers” who might know little to nothing about image optimization and sometimes upload huge images unaware of the consequences.&lt;/p&gt;

&lt;p&gt;So I was a bit disappointed but decided to move forward with the feature. I was after all seeing some improvement but more on the order of 5%.&lt;/p&gt;

&lt;p&gt;A couple days later I plugged RequestReduce into this blog. While it was very effective in reducing the number of HTTP requests, it appeared as though the total count of downloaded bytes was greater that before implementing RequestReduce. How could this be? With the minification of the CSS, it would certainly be less right? Apparently not. The main culprit was a JPG image that was originally abut&amp;#160; 5k and was consuming well over this amount in my sprite.I figured this was a flaw I had to fix and I knew very little about the details of image optimization.&lt;/p&gt;

&lt;p&gt;My first inclination was that I was creating the image incorrectly. I assumed there was some encoder setting I was failing to set correctly that was forcing the generation of 32 bit PNGs. I spent hours googling only to find there were countless others with the same inclination and no solution. Previously I had reviewed the code written for the &lt;a href="http://aspnet.codeplex.com/releases/view/65787"&gt;Asp.Net Sprite Framework&lt;/a&gt;. This framework does something similar to RequestReduce but takes a very different approach that requires some intentional organization of the local image files before it can work. It had code, and eventually I had code that looked like this when finally generating the final PNG bitmap:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;div id="codeSnippetWrapper"&gt;
    &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] GetBytes(&lt;span style="color: #0000ff"&gt;string&lt;/span&gt; mimeType)&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;using&lt;/span&gt; (var spriteEncoderParameters = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; EncoderParameters(1))&lt;br /&gt;    {&lt;br /&gt;        spriteEncoderParameters.Param[0] = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; EncoderParameter(Encoder.Quality, 90);&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;using&lt;/span&gt; (var stream = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; MemoryStream())&lt;br /&gt;        {&lt;br /&gt;            SpriteImage.Save(stream, ImageCodecInfo.GetImageEncoders()&lt;br /&gt;            .First(x =&amp;gt; x.MimeType == mimeType), spriteEncoderParameters);&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; stream.GetBuffer();&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
  &lt;/div&gt;
Let me just set the record straight here because there are oodles of forum posts and stackoverflow answers concerning this and many give wrong or misleading answers. &lt;em&gt;The Encoder.Quality parameter does absolutely nothing in the default PNG encoder as well as most of the other encoder parameters. &lt;/em&gt;I had thought that this was where the bulk of my problem lied. It wasn’t. 

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;Eventually it became clear that this was not going to be solved by some hidden property in the GDI+ api which is the API exposed in .net BCL for image manipulation. I stumbled upon a concept called image quantization. The process of reducing the number of colors in an image. This is a key concept in getting a 32 bit PNG to convert to a 8 bit PNG because an 8 bit PNG can have no more than 256 colors. It has what is called an Indexed Color palette. A part of the PNG file structure holds pointers to 256 colors and then each pixel in the image gets its color from one of those pointers. Thus each pixel only consumes one bytem its 0-255 value pointing to its color on the palette. On the other hand, a 32 bit PNG is 4 bytes per pixel and each pixel can represent a different ARGB color value. A 32 bit PNG also has a lot of wasted space since in may have multiple pixels that use the same color but they each hold their own copy.&lt;/p&gt;

&lt;p&gt;So with this information it makes sense why my sprites had to be 32 bit PNGs. As I added images to the sprites, even if the individual images being added were 8 bit PNGs, I would inevitably accrue more than 256 colors, once that happens, an 8 bit PNG can no longer be used without some data loss. That said, data loss does not necessarily need to translate to “perceptible” quality loss. This is where color quantizers come into play.&lt;/p&gt;

&lt;p&gt;Typically image optimization for the web takes one to two paths of optimization: lossless and lossy. Lossless guaeantees no quality loss and implements various compression strategies to shrink the size of a PNG. Popular tools like &lt;a href="http://optipng.sourceforge.net/"&gt;Optipng&lt;/a&gt; or &lt;a href="http://pmt.sourceforge.net/pngcrush/"&gt;PngCrush&lt;/a&gt; utilize this method, The savings can sometimes be significant and other times not so much. However, the savings is always “free” of quality loss and is therefore highly advisable.&lt;/p&gt;

&lt;p&gt;Lossy compression does certainly run the risk of unacceptable quality loss but can often render images that are dramatically smaller than their 32 bit cousins and their quality loss is practically imperceptible. There is inevitably loss, but if the loss can either not be perceived at all or is so slight that the savings far outweigh the color loss, taking on the loss may be advisable. Often the deciding factor is the number of colors in the original image, The closer that number is to 256, the less quality loss there will be and therefore the less likely that any of this loss will be perceptible. RequestReduce’s default color limit to quantize is 5000. However, this rule is not concrete. There are images where noticable color loss may occur beyond 3000 colors and other times (especially dealing with photos, where 10000 images is fine to quantize.&lt;/p&gt;

&lt;p&gt;So I only managed to find one open source .net based library that provided quantization and I was not comfortable with its license. There are a couple of C based EXEs that perform fast and effective quantization. The ones I used were &lt;a href="http://www.libpng.org/pub/png/apps/pngquant.html"&gt;PNGQuant&lt;/a&gt; and &lt;a href="http://pngnq.sourceforge.net/"&gt;Pngnq&lt;/a&gt;. The difference is the algorithm they employ for the quantization. I found that these produced decent quality images but one of my images (a rating star) was always off color. and a couple sprites had images with gradients that did look rather awful after the quantization. I eventially tried tweaking my code to limit the number of colors stored in a single sprite. This meant producing up to 3 sprite images for a page which seemed to me to be compromising the benefit of the sprite.&lt;/p&gt;

&lt;p&gt;So I looked further into other quantization algorithms. I found an &lt;a href="http://msdn.microsoft.com/en-us/library/aa479306.aspx"&gt;old sample&lt;/a&gt; on MSDN that I also found in an older version of Paint.net source code. My images looked terrible using this sample. Then I stumbled upon &lt;a href="http://www.codeproject.com/KB/recipes/SimplePaletteQuantizer.aspx?display=Mobile"&gt;this article&lt;/a&gt; on Code Project. It was a C# library that contained several different quantization algorithms. They all looked quite subpar except for one: an &lt;a href="http://www.ece.mcmaster.ca/~xwu/cq.c"&gt;algorithm&lt;/a&gt; developed by Xiaolin Wu. My images looked perfect. I could not notice any loss. Furthermore, their sizes were even smaller than the images generated by the C exe libraries. There was just one catch: the algorithm assumed RGB values pixels with no alpha opacity value. Now this Code Project sample included an “alpha blending” technique that made the transparency “appear” to be visible but you had to know what the background color is to blend the transparency with. RequestReduce works with sites that it has no idea what the background color is.&lt;/p&gt;

&lt;p&gt;Thus began a three week journey to tweak Xiaolin Wu’s algorithm to include the fourth alpha layer. Let me just preface this with the fact that I have no math or statistics background to speak of. Sadly, someone with such a background probably would have spent a lot less time on this.But it was literally almost all I could think of for three weeks. It was the type of problem that I constantly felt I was about to solve within an hour but each breakthrough simply exposed a new problem that became more complex than I anticipated as I got closer.Before really jumping in, I had thought that adding the fourth Alpha dimension to RGB would be rather trivial. Just look for lines like:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;and change it to:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;I can do that and a lot of it was just that. Except for a few key parts. I’m not going to agonize the details of this discovery process. While perhaps theraputic to myself, it would have negative value for any reader. Suffice it to say that in the end after lots of scratch pads and notpad.exe windows full of random numbers and sequences, I eventually had a quantized image with 256 colors that looked really good, better and smaller than the ones produced by pngquant or pngnq. However they were not perfect.&lt;/p&gt;

&lt;p&gt;As one can assume, adding an extra byte for alpha will translate to a source image .with potentially much more colors than a fully opaque image. This is because, technically, the same color with a different alpha value, is a different value and competes for one of the 256 slots in the 8 bit PNG indexed palette. In fact, there is the potential for 256x more colors. So I was not surprised to find that these quantized images were of slightly lower quality that the ones produced by the RGB quantizer.&lt;/p&gt;

&lt;p&gt;Fortunately, in reality, the number of values used in the alpha channel are usually far less than those used in the RGB channels.That being the case, I took some liberties with the alpha values that increased the image quality while sacrificing the number of unique alpha values used. I used two strategies here:&lt;/p&gt;

&lt;p&gt;1. I created an AlphaThreshold value. This is a constant that I set but should be configurable if this were production code. Any alpha value equal to or below the threshold gets translated to 0. I set this threshold to 30, finding that values with an alpha of 30 or less are for the most part invisible.&lt;/p&gt;

&lt;p&gt;2. I normalized the source alpha values to their closest multiple of 70. Why 70? Because that is the number transmitted to me from the great master Astra who is the giver of justice in the curious singing forest. Gotta love Astra, A heart of gold that one..This essentially limits the number of values that the alpha channel can occupy but continues to allow for decent gradients. I’m sure there are images where this would not work well but it looks good on all the images I have processed so far.&lt;/p&gt;

&lt;p&gt;So lets dive into the code, You can find a complete working VS Solution on the &lt;a href="http://code.msdn.microsoft.com/Convert-32-bit-PNGs-to-81ef8c81"&gt;MSDN Samples Gallery&lt;/a&gt;. The process of quantization can be split into the following parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Read the unoptimized source image and create a histogram of its colors. Which colors are used and how often. &lt;/li&gt;

  &lt;li&gt;Break down this data into several cumulative arrays that will make it much more efficient to slice and dice. &lt;/li&gt;

  &lt;li&gt;Create 256 clusters of colors from which we will pick the resulting palette. This step is what sets Wu’s algorithm apart from others. It is a process of perpetually splitting the color space into pairs of boxes to find clusters of colors with minimal variance. &lt;/li&gt;

  &lt;li&gt;Iterate over the source image again to find find the actual color closest to the mean of each cluster (these will be our palette colors) and map each pixel to its appropriate cluster. &lt;/li&gt;

  &lt;li&gt;Generate the new quantized image from the data in step 4. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Again, what lends to the accuracy of this algorithm is the clustering of colors of minimal variance. It is looking for the core colors in the image and not simply the colors most often used. With lower quality algorithms, it is far more likely for parts of an image to appear discolored as a more predominant color in the image. The color may be somewhat similar but quite noticeably different. From my tests, the Wu algorithm seems to eliminate these inaccuracies. For a deeper analysis from the author himself see&amp;#160; &lt;a href="http://books.google.com/books?id=tQn2pILgt9wC&amp;amp;source=gbs_similarbooks"&gt;Graphics Gems vol. II&lt;/a&gt;, pp. 126-133.&lt;/p&gt;

&lt;h2&gt;Building the Histogram&lt;/h2&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;p&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; ColorData BuildHistogram(Bitmap sourceImage)&lt;br /&gt;{&lt;br /&gt;    var data = sourceImage.LockBits(Rectangle.FromLTRB(0, 0, sourceImage.Width, sourceImage.Height),&lt;br /&gt;                                    ImageLockMode.ReadOnly, sourceImage.PixelFormat);&lt;br /&gt;    var colorData = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; ColorData(MaxSideIndex);&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;&lt;br /&gt;    {&lt;br /&gt;        var byteLength = data.Stride &amp;lt; 0 ? -data.Stride : data.Stride;&lt;br /&gt;        var byteCount = Math.Max(1, BitDepth &amp;gt;&amp;gt; 3);&lt;br /&gt;        var offset = 0;&lt;br /&gt;        var buffer = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Byte[byteLength * sourceImage.Height];&lt;br /&gt;        var &lt;span style="color: #0000ff"&gt;value&lt;/span&gt; = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Byte[byteCount];&lt;br /&gt;&lt;br /&gt;        Marshal.Copy(data.Scan0, buffer, 0, buffer.Length);&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var y = 0; y &amp;lt; sourceImage.Height; y++)&lt;br /&gt;        {&lt;br /&gt;            var index = 0;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var x = 0; x &amp;lt; sourceImage.Width; x++)&lt;br /&gt;            {&lt;br /&gt;                var indexOffset = index &amp;gt;&amp;gt; 3;&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var valueIndex = 0; valueIndex &amp;lt; byteCount; valueIndex++)&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[valueIndex] = buffer[offset + valueIndex + indexOffset];&lt;br /&gt;&lt;br /&gt;                var indexAlpha = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)((&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] &amp;gt;&amp;gt; 3) + 1);&lt;br /&gt;                var indexRed = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)((&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Red] &amp;gt;&amp;gt; 3) + 1);&lt;br /&gt;                var indexGreen = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)((&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Green] &amp;gt;&amp;gt; 3) + 1);&lt;br /&gt;                var indexBlue = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)((&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Blue] &amp;gt;&amp;gt; 3) + 1);&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] &amp;gt; AlphaThreshold)&lt;br /&gt;                {&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] &amp;lt; 255)&lt;br /&gt;                    {&lt;br /&gt;                        var alpha = &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] + (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] % 70);&lt;br /&gt;                        &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(alpha &amp;gt; 255 ? 255 : alpha);&lt;br /&gt;                        indexAlpha = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)((&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha] &amp;gt;&amp;gt; 3) + 1);&lt;br /&gt;                    }&lt;br /&gt;&lt;br /&gt;                    colorData.Weights[indexAlpha, indexRed, indexGreen, indexBlue]++;&lt;br /&gt;                    colorData.MomentsRed[indexAlpha, indexRed, indexGreen, indexBlue] &lt;/p&gt;&lt;p&gt;                     += &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Red];&lt;br /&gt;                    colorData.MomentsGreen[indexAlpha, indexRed, indexGreen, indexBlue] &lt;/p&gt;&lt;p&gt;                     += &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Green];&lt;br /&gt;                    colorData.MomentsBlue[indexAlpha, indexRed, indexGreen, indexBlue] &lt;/p&gt;&lt;p&gt;                     += &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Blue];&lt;br /&gt;                    colorData.MomentsAlpha[indexAlpha, indexRed, indexGreen, indexBlue] &lt;/p&gt;&lt;p&gt;                     += &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha];&lt;br /&gt;                    colorData.Moments[indexAlpha, indexRed, indexGreen, indexBlue] &lt;/p&gt;&lt;p&gt;                     += (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha]*&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha]) +                                                              &lt;/p&gt;&lt;p&gt;                      (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Red]*&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Red]) +&lt;br /&gt;                      (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Green]*&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Green]) +&lt;br /&gt;                      (&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Blue]*&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Blue]);&lt;br /&gt;                }&lt;br /&gt;&lt;br /&gt;                colorData.QuantizedPixels.Add(BitConverter.ToInt32(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt;[] { indexAlpha, indexRed, &lt;/p&gt;&lt;p&gt;                 indexGreen, indexBlue }, 0));&lt;br /&gt;                colorData.Pixels.Add(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Pixel(&lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Alpha], &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Red], &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Green], &lt;/p&gt;&lt;p&gt;                 &lt;span style="color: #0000ff"&gt;value&lt;/span&gt;[Blue]));&lt;br /&gt;                index += BitDepth;&lt;br /&gt;            }&lt;br /&gt;            offset += byteLength;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;finally&lt;/span&gt;&lt;br /&gt;    {&lt;br /&gt;        sourceImage.UnlockBits(data);&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; colorData;&lt;br /&gt;}&lt;br /&gt;&lt;/p&gt;&lt;/pre&gt;
This is rather straight forward with just two things to note. First, note that there are a few ways to iterate over the pixels of a bit map. Three that I can think of:&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;The simplest but by far the most inefficient is to simply create a for loop for x and y and call GetPixel(x,y) which returns the color of that pixel. &lt;/li&gt;

  &lt;li&gt;Use lockbits and unlock bits (as seen above) but with the difference of using pointers to iterate over the locked memory space of the image. This is much faster than technique number one but requires you to compile the code as unsafe. &lt;/li&gt;

  &lt;li&gt;Use lockbits and unlock but use Marshal.Copy to feed the memory into a buffer. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Second, note that we drop the three rightmost bit of each color dimension.This reduces the granularity of the color maps produced in the next step, making it much faster, This allows us to create our clusters using color values from 1 to 32 instead of 256.&lt;/p&gt;

&lt;h2&gt;Creating the Color Arrays&lt;/h2&gt;

&lt;p&gt;These are the data structures that all of the upcoming analysis is performed upon. If this step is off, everything else will be off. This is one of the steps that really led me down a rat hole. For the longest time I thought this was correct and was looking for bugs elsewhere.&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;p&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; ColorData CalculateMoments(ColorData data)&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var alphaIndex = 1; alphaIndex &amp;lt;= MaxSideIndex; ++alphaIndex)&lt;br /&gt;    {&lt;br /&gt;        var xarea = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        var xareaAlpha = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        var xareaRed = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        var xareaGreen = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        var xareaBlue = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        var xarea2 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;float&lt;/span&gt;[SideSize, SideSize, SideSize];&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var redIndex = 1; redIndex &amp;lt;= MaxSideIndex; ++redIndex)&lt;br /&gt;        {&lt;br /&gt;            var area = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize];&lt;br /&gt;            var areaAlpha = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize];&lt;br /&gt;            var areaRed = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize];&lt;br /&gt;            var areaGreen = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize];&lt;br /&gt;            var areaBlue = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[SideSize];&lt;br /&gt;            var area2 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;float&lt;/span&gt;[SideSize];&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var greenIndex = 1; greenIndex &amp;lt;= MaxSideIndex; ++greenIndex)&lt;br /&gt;            {&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; line = 0;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; lineAlpha = 0;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; lineRed = 0;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; lineGreen = 0;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; lineBlue = 0;&lt;br /&gt;                var line2 = 0.0f;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var blueIndex = 1; blueIndex &amp;lt;= MaxSideIndex; ++blueIndex)&lt;br /&gt;                {&lt;br /&gt;                    line += data.Weights[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;                    lineAlpha += data.MomentsAlpha[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;                    lineRed += data.MomentsRed[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;                    lineGreen += data.MomentsGreen[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;                    lineBlue += data.MomentsBlue[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;                    line2 += data.Moments[alphaIndex, redIndex, greenIndex, blueIndex];&lt;br /&gt;&lt;br /&gt;                    area[blueIndex] += line;&lt;br /&gt;                    areaAlpha[blueIndex] += lineAlpha;&lt;br /&gt;                    areaRed[blueIndex] += lineRed;&lt;br /&gt;                    areaGreen[blueIndex] += lineGreen;&lt;br /&gt;                    areaBlue[blueIndex] += lineBlue;&lt;br /&gt;                    area2[blueIndex] += line2;&lt;br /&gt;&lt;br /&gt;                    xarea[redIndex, greenIndex, blueIndex] = xarea[redIndex - 1, greenIndex, &lt;/p&gt;&lt;p&gt;                     blueIndex] + area[blueIndex];&lt;br /&gt;                    xareaAlpha[redIndex, greenIndex, blueIndex] = xareaAlpha[redIndex - 1, &lt;/p&gt;&lt;p&gt;                      greenIndex, blueIndex] + areaAlpha[blueIndex];&lt;br /&gt;                    xareaRed[redIndex, greenIndex, blueIndex] = xareaRed[redIndex - 1, &lt;/p&gt;&lt;p&gt;                      greenIndex, blueIndex] + areaRed[blueIndex];&lt;br /&gt;                    xareaGreen[redIndex, greenIndex, blueIndex] = xareaGreen[redIndex - 1, &lt;/p&gt;&lt;p&gt;                      greenIndex, blueIndex] + areaGreen[blueIndex];&lt;br /&gt;                    xareaBlue[redIndex, greenIndex, blueIndex] = xareaBlue[redIndex - 1, &lt;/p&gt;&lt;p&gt;                      greenIndex, blueIndex] + areaBlue[blueIndex];&lt;br /&gt;                    xarea2[redIndex, greenIndex, blueIndex] = xarea2[redIndex - 1, &lt;/p&gt;&lt;p&gt;                      greenIndex, blueIndex] + area2[blueIndex];&lt;br /&gt;&lt;br /&gt;                    data.Weights[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.Weights[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xarea[redIndex, greenIndex, blueIndex];&lt;br /&gt;                    data.MomentsAlpha[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.MomentsAlpha[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xareaAlpha[redIndex, greenIndex, blueIndex];&lt;br /&gt;                    data.MomentsRed[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.MomentsRed[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xareaRed[redIndex, greenIndex, blueIndex];&lt;br /&gt;                    data.MomentsGreen[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.MomentsGreen[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xareaGreen[redIndex, greenIndex, blueIndex];&lt;br /&gt;                    data.MomentsBlue[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.MomentsBlue[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xareaBlue[redIndex, greenIndex, blueIndex];&lt;br /&gt;                    data.Moments[alphaIndex, redIndex, greenIndex, blueIndex] = &lt;/p&gt;&lt;p&gt;                      data.Moments[alphaIndex - 1, redIndex, greenIndex, blueIndex] + &lt;/p&gt;&lt;p&gt;                      xarea2[redIndex, greenIndex, blueIndex];&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; data;&lt;br /&gt;}&lt;br /&gt;&lt;/p&gt;&lt;/pre&gt;

  &lt;br /&gt;In the end you should have a set of multi dimensional arrays that cumulatively increase both vertically down each “line” (or most finely grained dimension – blue here) and across to the right from A to R to G to B. The very last value in the array should be the total sum of the original array.&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;Arranging the data n this way allows you to make very efficient measurements on regions of the color space from just a few calculations instead of having to iterate over every point.&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;h2&gt;Clustering the Data&lt;/h2&gt;

&lt;p&gt;There is a fair amount of code involved here so I will not include all of it. Here is the entry point into this step:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;p&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; IList&amp;lt;Box&amp;gt; SplitData(&lt;span style="color: #0000ff"&gt;ref&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; colorCount, ColorData data)&lt;br /&gt;{&lt;br /&gt;    --colorCount;&lt;br /&gt;    var next = 0;&lt;br /&gt;    var volumeVariance = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;float&lt;/span&gt;[MaxColor];&lt;br /&gt;    var cubes = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Box[MaxColor];&lt;br /&gt;    cubes[0].AlphaMaximum = MaxSideIndex;&lt;br /&gt;    cubes[0].RedMaximum = MaxSideIndex;&lt;br /&gt;    cubes[0].GreenMaximum = MaxSideIndex;&lt;br /&gt;    cubes[0].BlueMaximum = MaxSideIndex;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var cubeIndex = 1; cubeIndex &amp;lt; colorCount; ++cubeIndex)&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (Cut(data, &lt;span style="color: #0000ff"&gt;ref&lt;/span&gt; cubes[next], &lt;span style="color: #0000ff"&gt;ref&lt;/span&gt; cubes[cubeIndex]))&lt;br /&gt;        {&lt;br /&gt;            volumeVariance[next] = &lt;/p&gt;&lt;p&gt;              cubes[next].Size &amp;gt; 1 ? CalculateVariance(data, cubes[next]) : 0.0f;&lt;br /&gt;            volumeVariance[cubeIndex] = &lt;/p&gt;&lt;p&gt;              cubes[cubeIndex].Size &amp;gt; 1 ? CalculateVariance(data, cubes[cubeIndex]) : 0.0f;&lt;br /&gt;        }&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;&lt;br /&gt;        {&lt;br /&gt;            volumeVariance[next] = 0.0f;&lt;br /&gt;            cubeIndex--;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        next = 0;&lt;br /&gt;        var temp = volumeVariance[0];&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var index = 1; index &amp;lt;= cubeIndex; ++index)&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (volumeVariance[index] &amp;lt;= temp) &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;;&lt;br /&gt;            temp = volumeVariance[index];&lt;br /&gt;            next = index;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (temp &amp;gt; 0.0) &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;;&lt;br /&gt;        colorCount = cubeIndex + 1;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; cubes.Take(colorCount).ToList();&lt;br /&gt;}&lt;/p&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;To dive deeper into what is going on, follow the Cut method. Note that this is looking to build 256 clusters of the smallest possible variance. One interesting piece of code a bit deeper down that I would like to point out is the calculation to obtain the volume of each cube. This demonstrates how the cumulative array allows you to make this calculation without iterating each element in the array:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; Volume(Box cube, &lt;span style="color: #0000ff"&gt;long&lt;/span&gt;[,,,] moment)&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (moment[cube.AlphaMaximum, cube.RedMaximum, cube.GreenMaximum, cube.BlueMaximum] -&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMaximum, cube.GreenMinimum, cube.BlueMaximum] -&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMinimum, cube.GreenMaximum, cube.BlueMaximum] +&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMinimum, cube.GreenMinimum, cube.BlueMaximum] -&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMaximum, cube.GreenMaximum, cube.BlueMaximum] +&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMaximum, cube.GreenMinimum, cube.BlueMaximum] +&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMinimum, cube.GreenMaximum, cube.BlueMaximum] -&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMinimum, cube.GreenMinimum, cube.BlueMaximum]) -&lt;br /&gt;&lt;br /&gt;            (moment[cube.AlphaMaximum, cube.RedMaximum, cube.GreenMaximum, cube.BlueMinimum] -&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMaximum, cube.GreenMaximum, cube.BlueMinimum] -&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMaximum, cube.GreenMinimum, cube.BlueMinimum] +&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMaximum, cube.GreenMinimum, cube.BlueMinimum] -&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMinimum, cube.GreenMaximum, cube.BlueMinimum] +&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMinimum, cube.GreenMaximum, cube.BlueMinimum] +&lt;br /&gt;            moment[cube.AlphaMaximum, cube.RedMinimum, cube.GreenMinimum, cube.BlueMinimum] -&lt;br /&gt;            moment[cube.AlphaMinimum, cube.RedMinimum, cube.GreenMinimum, cube.BlueMinimum]);&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;Just 15 simple arithmetic operations instead of 32768. This is another formula that I agonized over for days. The trick is figuring out where to put the pluses and minuses. The original RGB method is:&lt;/div&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; Int64 Volume(WuColorCube cube, Int64[, ,] moment)&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; moment[cube.RedMaximum, cube.GreenMaximum, cube.BlueMaximum] -&lt;br /&gt;           moment[cube.RedMaximum, cube.GreenMaximum, cube.BlueMinimum] -&lt;br /&gt;           moment[cube.RedMaximum, cube.GreenMinimum, cube.BlueMaximum] +&lt;br /&gt;           moment[cube.RedMaximum, cube.GreenMinimum, cube.BlueMinimum] -&lt;br /&gt;           moment[cube.RedMinimum, cube.GreenMaximum, cube.BlueMaximum] +&lt;br /&gt;           moment[cube.RedMinimum, cube.GreenMaximum, cube.BlueMinimum] +&lt;br /&gt;           moment[cube.RedMinimum, cube.GreenMinimum, cube.BlueMaximum] -&lt;br /&gt;           moment[cube.RedMinimum, cube.GreenMinimum, cube.BlueMinimum];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;The similarity is obvious. The key is building the arrays correctly. With incorrect data, this formula will never come out right. I also did not expect the addition of alpha to require parentheses.&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;h2&gt;Generating the Final Palette&lt;/h2&gt;

&lt;p&gt;This builds the final data structure we need to create out quantized image:&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;p&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; QuantizedPalette GetQuantizedPalette(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; colorCount, ColorData data, &lt;/p&gt;&lt;p&gt;                                                    IEnumerable&amp;lt;Box&amp;gt; cubes)&lt;br /&gt;{&lt;br /&gt;    var imageSize = data.Pixels.Count;&lt;br /&gt;    var lookups = BuildLookups(cubes, data);&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(var index = 0; index &amp;lt; imageSize; ++index)&lt;br /&gt;    {&lt;br /&gt;        var indexParts = BitConverter.GetBytes(data.QuantizedPixels[index]);&lt;br /&gt;        data.QuantizedPixels[index] = lookups.Tags[indexParts[Alpha], &lt;br /&gt;        indexParts[Red], indexParts[Green], indexParts[Blue]];&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    var alphas = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;[colorCount + 1];&lt;br /&gt;    var reds = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;[colorCount + 1];&lt;br /&gt;    var greens = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;[colorCount + 1];&lt;br /&gt;    var blues = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;[colorCount + 1];&lt;br /&gt;    var sums = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;[colorCount + 1];&lt;br /&gt;    var palette = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; QuantizedPalette(imageSize);&lt;br /&gt;    var index2 = -1;&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt; (var pixel &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; data.Pixels)&lt;br /&gt;    {&lt;br /&gt;        palette.PixelIndex[++index2] = -1;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(pixel.Alpha &amp;lt;= AlphaThreshold)&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;        var match = data.QuantizedPixels[index2];&lt;br /&gt;        var bestMatch = match;&lt;br /&gt;        var bestDistance = 100000000;&lt;br /&gt;        var index = -1;&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt; (var lookup &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; lookups.Lookups)&lt;br /&gt;        {&lt;br /&gt;            ++index;&lt;br /&gt;            var deltaAlpha = pixel.Alpha - lookup.Alpha;&lt;br /&gt;            var deltaRed = pixel.Red - lookup.Red;&lt;br /&gt;            var deltaGreen = pixel.Green - lookup.Green;&lt;br /&gt;            var deltaBlue = pixel.Blue - lookup.Blue;&lt;br /&gt;&lt;br /&gt;            var distance = deltaAlpha * deltaAlpha + deltaRed * deltaRed &lt;br /&gt;            + deltaGreen * deltaGreen + deltaBlue * deltaBlue;&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (distance &amp;gt;= bestDistance) &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;            bestDistance = distance;&lt;br /&gt;            bestMatch = index;&lt;br /&gt;        }&lt;br /&gt;        &lt;br /&gt;        alphas[bestMatch] += pixel.Alpha;&lt;br /&gt;        reds[bestMatch] += pixel.Red;&lt;br /&gt;        greens[bestMatch] += pixel.Green;&lt;br /&gt;        blues[bestMatch] += pixel.Blue;&lt;br /&gt;        sums[bestMatch]++;&lt;br /&gt;&lt;br /&gt;        palette.PixelIndex[index2] = bestMatch;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var paletteIndex = 0; paletteIndex &amp;lt; colorCount; paletteIndex++)&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (sums[paletteIndex] &amp;gt; 0)&lt;br /&gt;        {&lt;br /&gt;            alphas[paletteIndex] /= sums[paletteIndex];&lt;br /&gt;            reds[paletteIndex] /= sums[paletteIndex];&lt;br /&gt;            greens[paletteIndex] /= sums[paletteIndex];&lt;br /&gt;            blues[paletteIndex] /= sums[paletteIndex];&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        var color = Color.FromArgb(alphas[paletteIndex], reds[paletteIndex], &lt;br /&gt;            greens[paletteIndex], blues[paletteIndex]);&lt;br /&gt;        palette.Colors.Add(color);&lt;br /&gt;    }&lt;br /&gt;    palette.Colors.Add(Color.FromArgb(0, 0, 0, 0));&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; palette;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; LookupData BuildLookups(IEnumerable&amp;lt;Box&amp;gt; cubes, ColorData data)&lt;br /&gt;{&lt;br /&gt;    var lookups = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; LookupData(SideSize);&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;foreach&lt;/span&gt; (var cube &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; cubes)&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var alphaIndex = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(cube.AlphaMinimum + 1); alphaIndex &amp;lt;= cube.AlphaMaximum; ++alphaIndex)&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var redIndex = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(cube.RedMinimum + 1); redIndex &amp;lt;= cube.RedMaximum; ++redIndex)&lt;br /&gt;            {&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var greenIndex = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(cube.GreenMinimum + 1); greenIndex &amp;lt;= cube.GreenMaximum; ++greenIndex)&lt;br /&gt;                {&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var blueIndex = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(cube.BlueMinimum + 1); blueIndex &amp;lt;= cube.BlueMaximum; ++blueIndex)&lt;br /&gt;                        lookups.Tags[alphaIndex, redIndex, greenIndex, blueIndex] = lookups.Lookups.Count;&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        var weight = Volume(cube, data.Weights);&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (weight &amp;lt;= 0) &lt;span style="color: #0000ff"&gt;continue&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;        var lookup = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Lookup&lt;br /&gt;                         {&lt;br /&gt;                             Alpha = (&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;) (Volume(cube, data.MomentsAlpha)/weight),&lt;br /&gt;                             Red = (&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;) (Volume(cube, data.MomentsRed)/weight),&lt;br /&gt;                             Green = (&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;) (Volume(cube, data.MomentsGreen)/weight),&lt;br /&gt;                             Blue = (&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;) (Volume(cube, data.MomentsBlue)/weight)&lt;br /&gt;                         };&lt;br /&gt;        lookups.Lookups.Add(lookup);&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; lookups;&lt;br /&gt;}&lt;/p&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h2&gt;Building the Image&lt;/h2&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; Bitmap ProcessImagePixels(Image sourceImage, QuantizedPalette palette)&lt;br /&gt;{&lt;br /&gt;    var result = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Bitmap(sourceImage.Width, sourceImage.Height, PixelFormat.Format8bppIndexed);&lt;br /&gt;    var newPalette = result.Palette;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var index = 0; index &amp;lt; palette.Colors.Count; index++)&lt;br /&gt;        newPalette.Entries[index] = palette.Colors[index];&lt;br /&gt;    result.Palette = newPalette;&lt;br /&gt;&lt;br /&gt;    BitmapData targetData = &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;try&lt;/span&gt;&lt;br /&gt;    {&lt;br /&gt;        targetData = result.LockBits(Rectangle.FromLTRB(0, 0, result.Width, result.Height), &lt;br /&gt;            ImageLockMode.WriteOnly, result.PixelFormat);&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; targetBitDepth = 8;&lt;br /&gt;        var targetByteLength = targetData.Stride &amp;lt; 0 ? -targetData.Stride : targetData.Stride;&lt;br /&gt;        var targetByteCount = Math.Max(1, targetBitDepth &amp;gt;&amp;gt; 3);&lt;br /&gt;        var targetSize = targetByteLength * result.Height;&lt;br /&gt;        var targetOffset = 0;&lt;br /&gt;        var targetBuffer = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[targetSize];&lt;br /&gt;        var targetValue = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[targetByteCount];&lt;br /&gt;        var pixelIndex = 0;&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var y = 0; y &amp;lt; result.Height; y++)&lt;br /&gt;        {&lt;br /&gt;            var targetIndex = 0;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var x = 0; x &amp;lt; result.Width; x++)&lt;br /&gt;            {&lt;br /&gt;                var targetIndexOffset = targetIndex &amp;gt;&amp;gt; 3;&lt;br /&gt;                targetValue[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;)(palette.PixelIndex[pixelIndex] == -1 ? palette.Colors.Count - 1 : &lt;br /&gt;                    palette.PixelIndex[pixelIndex]);&lt;br /&gt;                pixelIndex++;&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (var valueIndex = 0; valueIndex &amp;lt; targetByteCount; valueIndex++)&lt;br /&gt;                    targetBuffer[targetOffset + valueIndex + targetIndexOffset] = targetValue[valueIndex];&lt;br /&gt;&lt;br /&gt;                targetIndex += targetBitDepth;&lt;br /&gt;            }&lt;br /&gt;&lt;br /&gt;            targetOffset += targetByteLength;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        Marshal.Copy(targetBuffer, 0, targetData.Scan0, targetSize);&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;finally&lt;/span&gt;&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(targetData != &lt;span style="color: #0000ff"&gt;null&lt;/span&gt;)&lt;br /&gt;            result.UnlockBits(targetData);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;Here we simply use our generated palette and fill in the pixels. &lt;/p&gt;

&lt;p&gt;If you would like to download a full copy of this code along with a .EXE wrapper to test the quality of the quantizations, you can download it from the &lt;a href="http://code.msdn.microsoft.com/Convert-32-bit-PNGs-to-81ef8c81"&gt;MSDN Code Samples Gallery&lt;/a&gt;.&lt;/p&gt;</content>
  <ispublished>True</ispublished>
  <isdeleted>False</isdeleted>
  <iscommentsenabled>True</iscommentsenabled>
  <pubDate>2011-09-05 06:06:59</pubDate>
  <lastModified>2012-03-20 15:22:21</lastModified>
  <raters>0</raters>
  <rating>0</rating>
  <slug>Convert-32-bit-PNGs-to-high-quality-8-bit-PNGs-with-C</slug>
  <tags />
  <comments>
    <comment id="4152e175-4419-40a1-aabb-b5e9ad1cbd91" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2011-09-07 06:22:23</date>
      <author>Matt Wrock's Blog</author>
      <email>trackback</email>
      <country />
      <ip>96.31.33.25</ip>
      <website>http://www.mattwrock.com/post/2011/09/07/Released-nQuant-net-8-bit-PNG-Quantizer.aspx</website>
      <content>Released: nQuant .net 8 bit PNG Quantizer

Released: nQuant .net 8 bit PNG Quantizer</content>
    </comment>
    <comment id="3a466b7e-511c-410c-98b9-1981b85c42b1" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2012-03-20 06:14:08</date>
      <author>Javier</author>
      <email>maurasastre@gmail.com</email>
      <country />
      <ip>88.2.137.4</ip>
      <moderatedby>mwrock</moderatedby>
      <avatar />
      <content>Great article. I was looking for a good quantizer ( as AForge is very limited at this aspect), and this seems very good. I will give a try!!

But...Why can&amp;#39;t i limit the number of colors? I do not want to use 256 colors always, i would like to have 64 colors or less.... </content>
    </comment>
    <comment id="ca8a0dd2-e326-41cb-b3f0-36524c63cced" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2012-03-20 06:22:21</date>
      <author>mwrock</author>
      <email>matt@mattwrock.com</email>
      <country />
      <ip>50.46.255.50</ip>
      <avatar />
      <content>@Javier,

I may be taking a fresh look at nquant soon and optimizing it a bit. Please free to add issues to the nquant.codeplex.com site and I&amp;#39;ll try to fit that in. I also take pull requests from anyone interested in providing their own enhancements.

Thanks!</content>
    </comment>
    <comment id="0ec7996c-d4cc-4878-92de-03c239f94532" parentid="00000000-0000-0000-0000-000000000000" approved="True" spam="False" deleted="False">
      <date>2014-08-19 01:24:47</date>
      <author>mattwp.azurewebsites.net</author>
      <email>pingback</email>
      <country />
      <ip>168.62.22.219</ip>
      <website>http://mattwp.azurewebsites.net/?p=1881</website>
      <content>Pingback from mattwp.azurewebsites.net

nQuant Reduces The Visual Studio Gallery and MSDN Code Samples page size down by 10% | mattwrock</content>
    </comment>
  </comments>
  <categories />
  <notifications>
    <email>Swatijain27feb@gmail.com</email>
    <email>maurasastre@gmail.com</email>
    <email>sabaattitute@gmail.com</email>
  </notifications>
</post>